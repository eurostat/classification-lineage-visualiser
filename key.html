<!DOCTYPE html>
<html>
<head>
  <script src="https://d3js.org/d3.v6.min.js"></script>
</head>
<body>
 <script>
  // Fetch the data
  fetch('http://localhost:5500/Query-9.json')
    .then(response => {
      if (!response.ok) {
        throw new Error('Network response was not ok');
      }
      return response.json();
    })
    .then(data => {
      const bindings = data.results.bindings;
      const startId =  '321511000080'; // Replace with your starting ID
      // const startId = '846229100080';
      const startYear = 2018; // Replace with the starting year for your given ID

      const processData = (bindings, startId, startYear) => {
        const nodes = [];
        const edges = [];
        const idToNodes = {};
        const processed = new Set(); // Set to keep track of processed nodes
        const queue = [{ id: startId, year: startYear }];

        // Map source IDs and target IDs to their records for quick lookup
        const sourceMap = {};
        const targetMap = {};

        // Function to extract ID from URI
        const extractId = (uri) => uri.split('/').pop();

        bindings.forEach(record => {
          const sourceId = extractId(record.source.value);
          const targetId = extractId(record.target.value);
          const year = parseInt(record.year.value);

          if (!sourceMap[sourceId]) sourceMap[sourceId] = [];
          if (!targetMap[targetId]) targetMap[targetId] = [];

          sourceMap[sourceId].push({ targetId, year });
          targetMap[targetId].push({ sourceId, year });
        });


        // Function to create a node
        const createNode = (id, year) => {
          const node = {
            id: `${id}-${year}`,
            label: id,
            year: year,
            title: 'some title', // Replace with actual title if available
            x: calculateXPosition(year),
            y: calculateYPosition(id)
          };
          nodes.push(node);
          idToNodes[node.id] = node;
          return node;
        };

        // Function to calculate X position based on year
        const calculateXPosition = (year) => year * 100;

        // Function to calculate Y position based on ID
        const calculateYPosition = (id) => (parseInt(id) % 300) + 50;

        // Processing loop for descendants and ancestors
        while (queue.length > 0) {
          const { id, year } = queue.shift();
          const currentNodeKey = `${id}-${year}`;

          if (processed.has(currentNodeKey)) {
            continue; // Skip if this node has already been processed
          }
          processed.add(currentNodeKey);

          // Find descendants
          if (sourceMap[id]) {
            sourceMap[id].forEach(({ targetId, year }) => {
              if (!idToNodes[`${id}-${year}`]) createNode(id, year);
              if (!idToNodes[`${targetId}-${year + 1}`]) createNode(targetId, year + 1);

              edges.push({ source: `${id}-${year}`, target: `${targetId}-${year + 1}` });

              queue.push({ id: targetId, year: year + 1 });
            });
          }

          // Find ancestors
          if (targetMap[id]) {
            targetMap[id].forEach(({ sourceId, year }) => {
              if (!idToNodes[`${sourceId}-${year}`]) createNode(sourceId, year);
              if (!idToNodes[`${id}-${year + 1}`]) createNode(id, year + 1);

              edges.push({ source: `${sourceId}-${year}`, target: `${id}-${year + 1}` });

              queue.push({ id: sourceId, year: year });
            });
          }
        }

        // Ensure continuity of nodes
        const allYears = Array.from(new Set(nodes.map(node => node.year)));
        const minYear = Math.min(...allYears);
        const maxYear = Math.max(...allYears);

        for (let year = minYear; year <= maxYear; year++) {
          if (!idToNodes[`${startId}-${year}`]) {
            createNode(startId, year);
            if (year > minYear) {
              edges.push({
                source: `${startId}-${year - 1}`,
                target: `${startId}-${year}`
              });
            }
          }
        }

        return { nodes, edges };
      };

      const result = processData(bindings, startId, startYear);
      console.log(result.nodes);
      console.log(result.edges);
    })
    // .catch(error => { console.error('There has been a problem with your fetch operation:', error); });
</script>
</body>
</html>
